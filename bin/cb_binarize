#!/usr/bin/env python3

#https://github.com/pytorch/pytorch/issues/29893
import os
#os.environ["LRU_CACHE_CAPACITY"] = "1"
import time
import fargv
import torch
import PIL
from cbbin import *

p={
    "n_channels": 3,
    "n_classes": 2,
    "output_postfix": ".out.png",
    "images": set([]),
    "io_threads": 1,
    "tormentor_device": "cpu",
    "device": "cuda",
    "model": "./tmp/2009.pt",
    "overwrite": False,
    "max_device_mp": 5.0
}
p, _ = fargv.fargv(p, return_named_tuple=True)



print("Resuming Model ... ", end="")

model_param_dict = sorted(torch.load(p.model, map_location="cpu")["param_hist"].items())[-1][1]
net = create_net(model_param_dict["arch"], model_param_dict["n_channels"], model_param_dict["n_classes"], .99, False, False)
param_hist, per_epoch_train_errors, per_epoch_validation_errors, start_epoch, net = resume(net, p.model, p.device)
print("done!")
print("Computing images:")


all_res={}
total_start=time.time()
with torch.no_grad():
    for img_fname in p.images:
        out_filename = img_fname+p.output_postfix
        if os.path.isfile(out_filename) and not p.overwrite:
            print(f"Output file {out_filename} there, keeping.")
        else:
            print(f"Computing: {img_fname} ... ", end="")
            image_time = time.time()
            img = dibco_transform_color_input(PIL.Image.open(img_fname))
            img = img.unsqueeze(dim=0)
            if (img.size(2)*img.size(3))/1000000. > p.max_device_mp:
                device = "cpu"
            else:
                device = p.device
            img = img.to(device)
            net = net.to(device)
            out = net(img).detach().cpu().numpy()
            out = ((out[0, 0, :, :] > out[0, 1, :, :]) * 255.).astype("uint8")
            PIL.Image.fromarray(out).convert("RGB").save(out_filename)
            print(f" Done! saved as:  {out_filename}  duration: {int(1000*(time.time()-image_time))} msec.", end="")
